<style>    :root{      --bg1:#2b1f1a; --bg2:#f7ecf0;      --panel: rgba(255,255,255,0.06);      --accent: #e7a7b8;    }    html,body{height:100%;margin:0;font-family:Playfair Display, serif;background:      radial-gradient(circle at 10% 20%, rgba(255,230,240,0.06), transparent 8%),      radial-gradient(circle at 90% 80%, rgba(240,230,255,0.03), transparent 8%),      linear-gradient(180deg,#0f0b0a 0%, #2a1f1a 100%); color:#fff; -webkit-font-smoothing:antialiased;}    #ui {      position: fixed; left: 20px; top: 20px; z-index: 20; display:flex; flex-direction:column; gap:10px;      background: rgba(0,0,0,0.28); padding:12px; border-radius:12px; min-width:150px;      box-shadow: 0 6px 24px rgba(0,0,0,0.6);      border: 1px solid rgba(255,200,220,0.03);    }    #ui h3{margin:0;font-family: 'Great Vibes', cursive; font-size:20px; color: #ffdfe8; text-shadow:0 2px 8px rgba(0,0,0,0.6)}    .btn { background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)); border:none; padding:8px 10px; color:#fff; border-radius:8px; font-size:14px; cursor:pointer; }    .btn:active{ transform: translateY(1px); }    .btn.primary{ background: linear-gradient(180deg,#ffd4e6,#ff9cc9); color:#3b0620; font-weight:700; }    .row { display:flex; gap:8px; flex-wrap:wrap; }    #overlayText {      position: fixed; left:50%; transform: translateX(-50%); top: 34px; z-index:25; pointer-events:none;      text-align:center;    }    #overlayText h1 { margin:0; font-family:'Great Vibes', cursive; font-size:48px; color:#ffdfe8; text-shadow: 0 8px 24px rgba(0,0,0,0.8); }    #overlayText p { margin:6px 0 0 0; font-size:14px; color:rgba(255,255,255,0.8); font-family: Playfair Display, serif }    #credits { position:fixed; right:12px; bottom:12px; color:rgba(255,255,255,0.6); font-size:12px; z-index:20; }    canvas { display:block; }
    /* mobile UI tweaks */    @media (max-width:720px){      #ui { left: 10px; top: 10px; padding:10px; min-width:unset; }      #overlayText h1{ font-size:36px; }      .btn{ padding:8px 8px; font-size:13px; border-radius:10px; }    }  </style></head><body>
  <div id="overlayText">    <h1>Happy Birthday Eela</h1>    <p>— A Victorian Celebration — Tap to interact • Allow microphone to blow out candles</p>  </div>
  <div id="ui">    <h3>Victorian Table</h3>    <div class="row">      <button id="blowBtn" class="btn">Blow Candle</button>      <button id="cutBtn" class="btn">Cut Cake</button>    </div>    <div class="row">      <button id="musicBtn" class="btn">Play Music</button>      <button id="resetBtn" class="btn">Reset</button>    </div>    <div style="margin-top:6px;font-size:12px;opacity:0.9">Controls: drag to rotate, pinch to zoom (mobile) or scroll (desktop)</div>    <div style="margin-top:6px;font-size:12px;color:rgba(255,255,255,0.7)">Mic: <span id="micStatus">not active</span></div>  </div>
  <div id="credits">Made with — Victorian 3D Cake</div>
  <!-- three.js & controls from CDN -->  <script src="https://unpkg.com/three@0.156.0/build/three.min.js"></script>  <script src="https://unpkg.com/three@0.156.0/examples/js/controls/OrbitControls.js"></script>
  <script>  // --- Scene variables ---  let scene, camera, renderer, controls;  let cakeGroup, candle, flameSprite, raspberries = [], sliceMesh = null;  let mixer = null;  let clock = new THREE.Clock();  let micStream = null, audioCtx = null, analyser = null, dataArr = null;  let blowDetected = false;  let smokeParticles = [];  let particles = []; // celebration particles  let musicPlaying = false;
  // init  init();  animate();
  function init(){    // renderer    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });    renderer.setPixelRatio(window.devicePixelRatio);    renderer.setSize(window.innerWidth, window.innerHeight);    renderer.shadowMap.enabled = true;    renderer.shadowMap.type = THREE.PCFSoftShadowMap;    document.body.appendChild(renderer.domElement);
    // scene & camera    scene = new THREE.Scene();    scene.fog = new THREE.FogExp2(0x0f0b0a, 0.0012);    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 2000);    camera.position.set(0, 120, 420);
    // orbit controls    controls = new THREE.OrbitControls(camera, renderer.domElement);    controls.enableDamping = true;    controls.dampingFactor = 0.08;    controls.minDistance = 200;    controls.maxDistance = 800;    controls.maxPolarAngle = Math.PI * 0.9;
    // warm ambient & spot (Victorian warm light)    const amb = new THREE.AmbientLight(0xffffff, 0.35);    scene.add(amb);    const bulb = new THREE.PointLight(0xfff0e6, 0.9, 1200, 2);    bulb.position.set(180, 260, 250);    bulb.castShadow = true;    scene.add(bulb);
    // a subtle fill from the left    const leftFill = new THREE.DirectionalLight(0xffe6f0, 0.2);    leftFill.position.set(-300, 100, -300);    scene.add(leftFill);
    // ornate backdrop (plane with subtle texture via gradient)    const bgGeo = new THREE.PlaneGeometry(2000, 1200);    const bgMat = new THREE.MeshBasicMaterial({      color: 0x2a1f1a    });    const bgPlane = new THREE.Mesh(bgGeo, bgMat);    bgPlane.position.z = -600;    scene.add(bgPlane);
    // wooden table (large plane with slight glossy)    const tableGeo = new THREE.CircleGeometry(1200, 64);    const tableMat = new THREE.MeshStandardMaterial({ color: 0x23170f, roughness: 0.6, metalness: 0.05 });    const table = new THREE.Mesh(tableGeo, tableMat);    table.rotation.x = -Math.PI / 2;    table.position.y = -40;    table.receiveShadow = true;    scene.add(table);
    // add decorative centerpiece behind (a soft vignette via spheres)    const decorGeo = new THREE.SphereGeometry(260, 32, 32);    const decorMat = new THREE.MeshBasicMaterial({ color: 0x12090a, opacity: 0.6, transparent:true });    const decor = new THREE.Mesh(decorGeo, decorMat);    decor.position.set(-50, 80, -300);    decor.scale.set(1.2,0.55,1);    scene.add(decor);
    // cake group    cakeGroup = new THREE.Group();    cakeGroup.position.set(0, 40, 0);    scene.add(cakeGroup);
    buildCake();
    // soft sparkles in the air    for (let i=0;i<40;i++){      const s = new THREE.Mesh(new THREE.SphereGeometry(2.6,6,6), new THREE.MeshBasicMaterial({ color:0xffe7f0, transparent:true, opacity:0.12 }));      s.position.set( (Math.random()-0.5)*700, Math.random()*200+40, (Math.random()-0.5)*500 );      scene.add(s);      particles.push(s);    }
    // events    window.addEventListener('resize', onWindowResize);    document.getElementById('blowBtn').addEventListener('click', manualBlow);    document.getElementById('cutBtn').addEventListener('click', cutCake);    document.getElementById('musicBtn').addEventListener('click', toggleMusic);    document.getElementById('resetBtn').addEventListener('click', resetScene);
    // start microphone detection    initMicrophone();  }
  // Build the Black Forest Cake  function buildCake(){    // remove old if exists    if (cakeGroup) {      while (cakeGroup.children.length) cakeGroup.remove(cakeGroup.children[0]);    }
    // plate    const plateGeo = new THREE.CylinderGeometry(150, 150, 8, 64);    const plateMat = new THREE.MeshStandardMaterial({ color:0xfff7f0, roughness:0.45, metalness:0.1 });    const plate = new THREE.Mesh(plateGeo, plateMat);    plate.rotation.x = Math.PI/2;    plate.position.y = -18;    plate.receiveShadow = true;    cakeGroup.add(plate);
    // cake body (3 stacked cylinders to fake layers)    const layerHeights = [48, 44, 44];    const colors = [0x3c241c, 0x341a14, 0x2c0f10]; // dark chocolate tones    let y = 0;    for (let i=0;i<3;i++){      const g = new THREE.CylinderGeometry(90,90,layerHeights[i],64);      const mat = new THREE.MeshStandardMaterial({ color: colors[i], roughness:0.7, metalness:0.02 });      const m = new THREE.Mesh(g, mat);      m.position.y = y + layerHeights[i]/2;      m.castShadow = true;      m.receiveShadow = true;      cakeGroup.add(m);      y += layerHeights[i];    }
    // top frosting (darker but glossy)    const topGeo = new THREE.CylinderGeometry(92,92,18,64);    const topMat = new THREE.MeshStandardMaterial({ color:0x4a2b26, roughness:0.3, metalness:0.03, emissive:0x200a08, emissiveIntensity:0.02 });    const top = new THREE.Mesh(topGeo, topMat);    top.position.y = y + 9;    top.castShadow = false;    cakeGroup.add(top);
    // chocolate drip decoration (simple geometry using spheres)    for (let i=0;i<18;i++){      const drip = new THREE.Mesh(new THREE.SphereGeometry(7,12,10), new THREE.MeshStandardMaterial({ color:0x2f1a17, roughness:0.4 }));      const ang = (i/18)*Math.PI*2;      const r = 85 + Math.random()*6;      const dx = Math.cos(ang)*r;      const dz = Math.sin(ang)*r;      drip.position.set(dx, y+4 - Math.random()*18, dz);      drip.scale.y = 1 + Math.random()*1.6;      cakeGroup.add(drip);    }
    // raspberries on top — 7 around    raspberries = [];    const topY = y + 12;    for (let i=0;i<7;i++){      const a = (i/7) * Math.PI*2;      const rx = Math.cos(a)*50;      const rz = Math.sin(a)*50;      const r = makeRaspberry();      r.position.set(rx, topY + 6 + Math.random()*2, rz);      cakeGroup.add(r);      raspberries.push(r);    }
    // candle (thin tall cylinder)    const candleGeo = new THREE.CylinderGeometry(4,4,36,12);    const candleMat = new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.6 });    candle = new THREE.Mesh(candleGeo, candleMat);    candle.position.set(0, topY + 26, 0);    candle.castShadow = true;    cakeGroup.add(candle);
    // flame sprite (billboard)    const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=128;    const ctx = canvas.getContext('2d');    const grd = ctx.createRadialGradient(32,32,4,32,48,48);    grd.addColorStop(0,'rgba(255,255,200,1)'); grd.addColorStop(0.4,'rgba(255,220,50,0.95)'); grd.addColorStop(1,'rgba(255,140,20,0.06)');    ctx.fillStyle = grd; ctx.beginPath(); ctx.ellipse(32,48,18,36,0,0,2*Math.PI); ctx.fill();
    const tex = new THREE.CanvasTexture(canvas);    const flameMat = new THREE.SpriteMaterial({ map:tex, transparent:true, blending: THREE.AdditiveBlending });    flameSprite = new THREE.Sprite(flameMat);    flameSprite.scale.set(20,40,1);    flameSprite.position.set(0, topY + 40, 0);    cakeGroup.add(flameSprite);
    // small shadow under cake    const shadowGeo = new THREE.CircleGeometry(110, 32);    const shadowMat = new THREE.MeshBasicMaterial({ color:0x000000, opacity:0.18, transparent:true });    const shadow = new THREE.Mesh(shadowGeo, shadowMat);    shadow.rotation.x = -Math.PI/2;    shadow.position.y = -20;    cakeGroup.add(shadow);
    // make a 'slice wedge' but keep it hidden until cut    createSliceWedge();  }
  function makeRaspberry(){    const group = new THREE.Group();    const baseMat = new THREE.MeshStandardMaterial({ color:0xd31f3b, roughness:0.4, metalness:0.02 });    // base sphere    const s = new THREE.Mesh(new THREE.SphereGeometry(8,12,12), baseMat);    group.add(s);    // small bumps by instancing tiny spheres    for (let i=0;i<10;i++){      const b = new THREE.Mesh(new THREE.SphereGeometry(3.0,8,8), new THREE.MeshStandardMaterial({ color:0xc21839, roughness:0.45 }));      const ang = Math.random()*Math.PI*2;      const r = 6 + Math.random()*1.8;      b.position.set(Math.cos(ang)*r*0.12 + (Math.random()-0.5)*1.2, (Math.random()-0.5)*1.8, Math.sin(ang)*r*0.12);      group.add(b);    }    // small glossy top highlight by tiny emissive plane    const highlight = new THREE.Mesh(new THREE.SphereGeometry(2.6,6,6), new THREE.MeshBasicMaterial({ color:0xffffff, opacity:0.55, transparent:true }));    highlight.position.set(-3, -2.5, -2);    group.add(highlight);    return group;  }
  function createSliceWedge(){    // slice wedge built with CylinderGeometry using thetaLength small piece    const thetaLength = Math.PI/6; // 30 degrees slice    const wedgeGeo = new THREE.CylinderGeometry(90,90, (48+44+44), 64, 1, false, Math.PI/2 - thetaLength/2, thetaLength);    const wedgeMat = new THREE.MeshStandardMaterial({ color:0x3a1f1d, roughness:0.7 });    sliceMesh = new THREE.Mesh(wedgeGeo, wedgeMat);    sliceMesh.visible = false;    sliceMesh.position.y = (48+44+44)/2;    cakeGroup.add(sliceMesh);  }
  // --- microphone initialization and detection (smoothed RMS) ---  async function initMicrophone(){    try {      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });      micStream = stream;      audioCtx = new (window.AudioContext || window.webkitAudioContext)();      const source = audioCtx.createMediaStreamSource(stream);      analyser = audioCtx.createAnalyser();      analyser.fftSize = 512;      source.connect(analyser);      dataArr = new Uint8Array(analyser.fftSize);      document.getElementById('micStatus').textContent = 'active';      // continuously check levels      detectBlowFromMic();    } catch (e) {      console.warn('Mic not available:', e);      document.getElementById('micStatus').textContent = 'denied / unavailable';    }  }
  let blowCooldown = 0;  function detectBlowFromMic(){    if (!analyser) return;    requestAnimationFrame(detectBlowFromMic);    analyser.getByteTimeDomainData(dataArr);    // compute normalized RMS    let sum = 0;    for (let i=0;i<dataArr.length;i++){      const v = (dataArr[i] - 128) / 128;      sum += v*v;    }    const rms = Math.sqrt(sum / dataArr.length);    // smoothing    const thresh = 0.18; // tuned threshold    if (rms > thresh && blowCooldown <= 0 && flameSprite.visible){      blowDetected = true;      blowCooldown = 60; // frames cooldown      triggerBlowEffects();    }    if (blowCooldown > 0) blowCooldown--;  }
  // manual blow button fallback  function manualBlow(){    if (!flameSprite.visible) return;    triggerBlowEffects();  }
  function triggerBlowEffects(){    // extinguish    if (!flameSprite.visible) return;    flameSprite.visible = false;    createSmokeBurst();    playWhoosh();    setTimeout(() => { createSparkles(30); playApplause(); }, 600);  }
  function createSmokeBurst(){    // spawn some small smoke puffs    for (let i=0;i<18;i++){      smokeParticles.push({        x: cakeGroup.position.x + (Math.random()-0.5)*8,        y: cakeGroup.position.y + 140 + Math.random()*10,        z: (Math.random()-0.5)*6,        size: 6 + Math.random()*10,        life: 120 + Math.random()*40      });    }  }
  function createSparkles(count=20){    for (let i=0;i<count;i++){      const s = new THREE.Mesh(new THREE.SphereGeometry(2.5,6,6), new THREE.MeshBasicMaterial({ color: 0xffe6f0 }));      s.position.set( (Math.random()-0.5)*160, 80 + Math.random()*120, (Math.random()-0.5)*200 );      s.userData.life = 80 + Math.random()*60;      scene.add(s);      particles.push(s);    }  }
  // --- Cut cake (slice animation) ---  function cutCake(){    if (!sliceMesh || sliceMesh.visible) return;    // show slice wedge placed at cake position and animate out    sliceMesh.visible = true;    sliceMesh.position.set(0, sliceMesh.position.y, 0);    sliceMesh.rotation.y = 0;    // animate over frames: move wedge out & rotate    const totalFrames = 70;    let frame = 0;    const startPos = sliceMesh.position.clone();    const anim = () => {      frame++;      const t = easeOutCubic(frame/totalFrames);      sliceMesh.position.x = 160 * t;      sliceMesh.position.z = -40 * Math.sin(t * Math.PI/2);      sliceMesh.rotation.z = -Math.PI * 0.12 * t;      // small crumb particles      if (frame % 6 === 0) spawnCrumb();      if (frame < totalFrames) requestAnimationFrame(anim); else {        // done        playSliceSound();        setTimeout(()=>{ sliceMesh.visible = false; createSparkles(40); }, 400);      }    };    anim();  }
  function spawnCrumb(){    const crumb = new THREE.Mesh(new THREE.SphereGeometry(1.6,6,6), new THREE.MeshStandardMaterial({ color:0x6b3d32 }));    crumb.position.copy(cakeGroup.position).add(new THREE.Vector3((Math.random()-0.5)*20, 30, (Math.random()-0.5)*20));    crumb.userData.vel = new THREE.Vector3((Math.random()-0.5)*2, Math.random()*3, (Math.random()-0.5)*2);    crumb.userData.life = 80 + Math.random()*40;    scene.add(crumb);    particles.push(crumb);  }
  // --- Sounds (synthesized) ---  function playWhoosh(){    try {      const ctx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();      const o = ctx.createOscillator();      const g = ctx.createGain();      o.type = 'sine';      o.frequency.value = 600;      g.gain.value = 0.0001;      o.connect(g); g.connect(ctx.destination);      o.start();      const now = ctx.currentTime;      g.gain.linearRampToValueAtTime(0.28, now + 0.01);      o.frequency.exponentialRampToValueAtTime(80, now + 0.35);      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);      setTimeout(()=>o.stop(), 700);    } catch(e){console.warn(e);}  }
  function playSliceSound(){    try {      const ctx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();      const noise = ctx.createBufferSource();      const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.25, ctx.sampleRate);      const data = buffer.getChannelData(0);      for (let i=0;i<data.length;i++){ data[i] = (Math.random()*2-1) * Math.exp(-i/data.length*4); }      noise.buffer = buffer;      const g = ctx.createGain();      g.gain.value = 0.5;      noise.connect(g); g.connect(ctx.destination);      noise.start();      setTimeout(()=>noise.stop(), 300);    } catch(e){console.warn(e);}  }
  function playApplause(){    try {      const ctx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();      for (let i=0;i<6;i++){        const o = ctx.createOscillator();        const g = ctx.createGain();        o.type = 'triangle';        o.frequency.value = 300 + i*30 + Math.random()*60;        g.gain.value = 0.0001;        o.connect(g); g.connect(ctx.destination);        const now = ctx.currentTime + i*0.03;        o.start(now);        g.gain.linearRampToValueAtTime(0.08, now + 0.02);        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.15 + Math.random()*0.2);        o.stop(now + 0.3 + Math.random()*0.2);      }    } catch(e){console.warn(e);}  }
  // simple background music (Victorian-ish arpeggio)  let musicOscs = [];  function toggleMusic(){    if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();    if (!musicPlaying){      musicPlaying = true;      document.getElementById('musicBtn').textContent = 'Pause Music';      playVictorianLoop();    } else {      musicPlaying = false;      document.getElementById('musicBtn').textContent = 'Play Music';      // stop oscillators      musicOscs.forEach(o=>{ try{o.stop();}catch(e){} });      musicOscs = [];    }  }
  function playVictorianLoop(){    if (!musicPlaying) return;    const ctx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();    const now = ctx.currentTime;    const pattern = [0, 3, 7, 10]; // intervals (minor-ish)    for (let i=0;i<pattern.length;i++){      const o = ctx.createOscillator();      const g = ctx.createGain();      o.type = 'sine';      o.frequency.value = 220 * Math.pow(2, pattern[i]/12);      g.gain.value = 0.0001;      o.connect(g); g.connect(ctx.destination);      o.start(now + i*0.5);      g.gain.linearRampToValueAtTime(0.08, now + i*0.5 + 0.02);      g.gain.exponentialRampToValueAtTime(0.0001, now + i*0.5 + 0.42);      o.stop(now + i*0.5 + 0.46);      musicOscs.push(o);    }    // loop    setTimeout(()=>{      if (musicPlaying) playVictorianLoop();    }, 2000);  }
  // reset scene (rebuild)  function resetScene(){    flameSprite.visible = true;    // remove any particles created    for (let p of particles){ try{ scene.remove(p); } catch(e){} }    particles = [];    // rebuild raspberries small jiggle reset    for (let r of raspberries){ r.position.y += 0; }    // rebuild slice    if (sliceMesh) { sliceMesh.visible = false; sliceMesh.position.set(0, sliceMesh.position.y, 0); sliceMesh.rotation.set(0,0,0); }  }
  // --- animation loop ---  function animate(){    requestAnimationFrame(animate);    const dt = clock.getDelta();
    // animate flame flicker (if visible)    if (flameSprite && flameSprite.visible){      const f = 1 + Math.sin(Date.now()*0.02)*0.08;      flameSprite.scale.set(16*f, 36*f, 1);      flameSprite.material.opacity = 0.92 + Math.sin(Date.now()*0.014)*0.07;    }
    // animate raspberries subtle bob    raspberries.forEach((r,i)=>{      r.rotation.y += 0.002*(i%3+1);      r.position.x += Math.sin(Date.now()*0.001 + i)*0.01;    });
    // update smoke particles    for (let i = smokeParticles.length - 1; i >= 0; i--){      const s = smokeParticles[i];      s.y += 0.6; // going up in world coords because cakeGroup is above      s.size *= 1.01;      s.life--;      if (s.life <= 0) smokeParticles.splice(i,1);    }
    // animate small particles (fade out)    for (let i = particles.length - 1; i >= 0; i--){      const p = particles[i];      if (p.userData){        p.userData.life -= 1;        p.position.y += 0.6;        p.material.opacity = Math.max(0, p.userData.life / 80);        if (p.userData.life <= 0){ scene.remove(p); particles.splice(i,1); }      } else {        // generic sparkle objects        p.rotation.y += 0.002;      }    }
    // crumb particles movement (those created by spawnCrumb)    for (let i = particles.length - 1; i >= 0; i--){      const p = particles[i];      if (p.userData && p.userData.vel){        p.position.add(p.userData.vel);        p.userData.vel.y -= 0.08; // gravity        p.userData.life--;        if (p.userData.life <= 0){ scene.remove(p); particles.splice(i,1); }      }    }
    controls.update();    renderer.render(scene, camera);  }
  function onWindowResize(){    camera.aspect = window.innerWidth/window.innerHeight;    camera.updateProjectionMatrix();    renderer.setSize(window.innerWidth, window.innerHeight);  }
  // --- utilities & easing ---  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
  // --- small helpers for UI: play click on cut etc. ---  function playSliceSound(){ /* defined earlier; left intentionally to call earlier version */ }  // ensure playSliceSound references the previously defined function  // (JS hoisting ensures earlier definition is used)
  </script></body></html>
